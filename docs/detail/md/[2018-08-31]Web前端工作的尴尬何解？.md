---
prev: false
next: ./[2018-09-02]需求评审中的逻辑陷阱.md
---
# Web前端工作的尴尬何解?<Badge text="原创"/>
<Tag>2018-08-31</Tag><Tag>转载请注明出处</Tag>
::: tip 摘要
Web前端工作面临着三个尴尬  

* 就是个做页面的，没啥技术含量
* 工作量在各方的理解上不一，难以评估
* 确认产品意图，接的后端的接口，实现了设计效果，就是搬运工，自己干了什么反而说不清楚  

概括起来就是，要你干啥，你能干啥，要你有啥用
:::

前端面对的尴尬，**一方面前端是各方的交汇点，承载了太多的诉求，职责边界不清晰；另一方面前端的高速发展与传统前端的割裂感太过于明显，被“看不懂”**。

云服务化以来，服务端架构的演变下，前端在架构上的位置被忽视，反而显得的急功近利，最后可能造成 **“项目成了，爷好汉；项目败了，是混蛋”** 的非客观评价。 

**个人观点：前端只是职责岗位划分，应当从JavaScript工程师视角出发，重新审视职业发展规划**

## 全栈能力
::: tip 观点
全栈不是全精全通，而是构建连接的能力
:::

## 业务驱动
::: tip 观点
做前端就是做业务，业务是驱动力和边界
:::

## UI/UX
::: tip 观点
UI/UX是传统前端的能力的基础，不能荒废
:::

切图以及界面效果而言，同样的一个页面效果，好也罢坏也罢，做出来能用就可以了，实话实说在实际开发过程当中是很难体现出差距的。这个是传统前端岗位的基础能力，这点做不到是不能够胜任前端的岗位。当下前端工程化演进，一方面拓宽职责范围，另一方面也是为UI/UX服务。

例如：前端组件化实现，难道只涉及到JavaScript语言本身？

当一个Tag组件的属性为size为large时(<code>&lt;Tag size="large"/&gt;</code>)，则font-size: 14px。以下是一个SCSS的面向对象封装（思路参考来自ElementUI）。
```scss
// tag
@include block(tag) {
  display: inline-block;
  font-size: 13px;
  padding: 0px 12px;
  border-radius: 3px;
  border: solid 1px black;
  color: black;
  font-weight: 400;

  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  overflow: hidden;

  @include nest(size) {
    @include impl(large) {
      font-size: 14px;
    }

    @include impl(small) {
      font-size: 12px;
    }

    @include impl(mini) {
      webkit-transform-origin-x: 0;
      -webkit-transform: scale(0.90);
      font-size:10.8px;
    }
  }
}
```

```scss
//mixins
@mixin block($block) {
  $name: $block !global;
  .#{$name} {
    @content;
  }
}

@mixin nest($item) {
  &-#{$item}{
    @content;
  }
}

@mixin impl($state) {
  @at-root {
    &-#{$state} {
      @content;
    }
  }
}
```

通过函数式的封装实现CSS面向对象表达，带来了以下几个优势

* 迁移使用方便（复用性）
* 代码可阅读性好（方便Review和编写)
* 方便写单元测试(自动化测试)

这是工程能力同时也是在为UI的稳定性输出服务。

一味的强调JavaScript工程能力，如果摆脱了UI/UX，那么前端岗位职责就是无根之木。

## 微服务
::: tip 观点
微服务架构下，不仅是样式&布局，“界面”相关的都在控制范围，构建连接
:::

## 组件化/模块化建设
::: tip 观点
组件化/模块化为基础的工具以及自动化建设，构建自身的工程体系
:::

## 缓存/中台建设
::: tip 观点
缓存/中台建设，突破浏览器限制
:::

## 敏捷开发
::: tip 观点
时间是效率，质量是生命线
:::

当下提起敏捷开发，不再只是高效的代名词，而成了加班，下游埋怨上游，上游无力为继的“现状”。“敏捷开发”成了一个遥不可及的理想，从而产生其对团队成员要求高，自动化程度要求高的印象。如果大家都承认，敏捷开发只有一流团队才能够建立起来，那么何不换个思路”以敏捷开发流程为参照，我们离一流团队的距离还有多远？“。**一味的说自身不适合敏捷开发诸多原因，其实是因果倒置的。**

以下主要围绕两个问题：
* 如何提高效率？

**把脑力劳动，变成体力劳动**，自动化工具要合理取舍，并不是所有的都是自动化（可配置）就是好的。

* 如何把控质量？

**质量问题要分级分类**，不能所有的问题都统归为质量事故，但是项目阶段不同、环境不同，虽然大体类似，应该建立适合团队本身的体系建设，**分分钟解决的问题就不叫问题，才能集中力量解决问题。**

详细的探讨可以移步到另一篇博文，[《工程化&效率》](./[2018-09-08]工程化&效率.md)会进行详细论述。

## 结尾

看到很多项目[Algolia搜索](https://community.algolia.com/docsearch/), [Google Analytics](https://analytics.google.com/)，[Hotjar](https://www.hotjar.com/)，[Keras.js](https://transcranial.github.io/keras-js/)这些项目从数据使用，数据分析，业务服务甚至是AI提供了非常多的便利，但是这些都不是所谓的“纯前端”和“纯后端”能单独做到的。

**面向实现本身构建问题，解决问题。**

JavaScript工程师，不应该被岗位所束缚。正因为前端的高速发展，才使得后端的接口可以简化成RESTFUL，更加的贴近系统资源抽象从而达到产品实现要求。因此个人认为，当下提到的“微前端”概念是很不好的说法，“微前端”建设其实很多是原有传统后端开发的体系范围。随着架构和工程体系演变，前端的职责范围被扩大了，这是市场的诉求。

**围绕着“界面”，构建独立的工程体系（解决方案）。**

**祝各位JavaScript工程师，工作顺利。**
